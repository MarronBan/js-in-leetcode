# 每日力扣

如题

## 3.13

题号：**[393.UTF-8编码验证](https://leetcode-cn.com/problems/utf-8-validation/)**

1.1字节的UTF-8字符为

```
0xxxxxxx
```

2.2字节的UTF-8字符为

- 第一个字节前n位为1，第n+1位为0
- 除第一个字节外的每个字节，前2位为10

```
110xxxxx 10xxxxxx
```

输入：一个数组，每一项是一个整数，表示一个字节的数据。

输出：该数组是否为有效的UTF-8编码

要做的事：

- 把整数转换成8位有效二进制 ->可替代方法：使用位运算得出第一位的值

  ```
  data[i].toString(2).padStart(8, '0')
  ```

- 判断该整数是1字节还是多字节以及是否合法 

  ```
  while(n<8){
  	let s = data[i]
  	if(s[n++]==='1'){
  		count++
  	}
  	if (s[n] === "0") {
  		break
  	}
  }
  count=0，跳过这个数
  count>4，不合法
  count=1且是开头的数,不合法
  for(let j = i+1;j < i+count; j++){
  	let s = data[j]
  	if(s[0]!=='1'||s[1]!=='0')
  		不合法
  }
  ```

  

## 3.14

题号：**[599.两个列表的最小索引总和](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)**

第一种思路：

- 建立双重循环，找到重复出现的餐厅
- 使用map，保存其中一个的索引（为了能输出餐厅名）和索引和（为了能算最小索引）
- 遍历map，找出所有最小索引组成数组返回

根据官方题解优化一下，既然使用了map大可用两个单独的循环搞定

- 遍历list1，用map保存餐厅名和索引值
- 遍历list2，在map查找list2[i]
- 若有，则判断是否是最小索引值，但考虑到之前会有较小的索引值，所以重置一次数组，再将餐厅名称加入数组。
- 如果有多个最小索引值，则都加入数组
- 同时，如果遍历list2时，发现索引和大于最小索引值，直接返回数组。

## 3.15

题号：**[2044. 统计按位或能得到最大值的子集数目](https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/)**

可以通过|获得按位或的值

```
2|5 ->7
2|1|5 ->7
```

思路：

- 找到数组的所有非空子集，除去只有一个元素的子集
- 对非空子集进行按位或，并用map保存值
- 遍历map找出最大的值，计算子集的个数

且因为题目只需要输出个数，所以可以在按位或的时候就判断大小，不需要保存子集了

如何找到数组的所有非空子集呢？

看了下题解是这么做的

```
for (let i = 0; i < (1 << len); i++) {
		let arr = [];
        for (let j = 0; j < len; j++) {
            if (i & (1 << j)) arr.push(nums[j]);
        }
        arr.length > 0 && res.push(arr);
}
```

首先`1<<len`表示将数字1左移`len`位，在数字没有溢出的情况下，相当于将`1*2^(len)`

```
1<<4 -> 1*2^4=16
```

非空子集的个数是由数组的个数决定的，公式为`2^n-1`，以`nums=[3,2,1,5]`为例

| 子集      | i                     | j    | i&(1<<j) |
| --------- | --------------------- | ---- | -------- |
| [3]       | 1/3/5/7/9/11/13/15    | 0    | 1        |
| [2]       | 2/3/6/7/10/11/14/15   | 1    | 2        |
| [3,2]     |                       |      |          |
| [1]       | 4/5/6/7/12/13/14/15   | 2    | 4        |
| [3,1]     |                       |      |          |
| [2,1]     |                       |      |          |
| [3,2,1]   |                       |      |          |
| [5]       | 8/9/10/11/12/13/14/15 | 3    | 8        |
| [3,5]     |                       |      |          |
| [2,5]     |                       |      |          |
| [3,2,5]   |                       |      |          |
| [1,5]     |                       |      |          |
| [3,1,5]   |                       |      |          |
| [2,1,5]   |                       |      |          |
| [3,2,1,5] |                       |      |          |

`i & (1 << j)`实现了对数组的全排列

第二步，对非空子集进行按位或

```
let result = []
	for (let i = 0; i < res.length; i++) {
		if (res[i].length === 1) {
			result.push(res[i][0] | 0)
			continue
		}
		let temp = 0
		res[i].forEach((item) => {
			temp |= item
		})
		result.push(temp)
}
```

第三步，找出按位或的最大值并统计最大值出现了多少次

```
const max = Math.max(...result)
	let ans = 0
	result.forEach((i) => {
		if (i === max) {
			ans++
		}
})
```

